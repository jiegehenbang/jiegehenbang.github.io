<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 异步编程之 Promise 详解</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        dark: '#1D2129',
                        light: '#F2F3F5'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['Fira Code', 'monospace']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .code-block {
                @apply bg-dark text-light p-4 rounded-lg overflow-x-auto font-mono text-sm my-4;
            }
            .nav-link {
                @apply px-4 py-2 hover:text-primary transition-colors duration-200;
            }
            .section-title {
                @apply text-2xl font-bold text-dark mb-6 mt-12 border-l-4 border-primary pl-3;
            }
            .card {
                @apply bg-white rounded-lg shadow-md p-6 mb-8;
            }
        }
    </style>
</head>
<body class="bg-light text-dark">
    <nav class="bg-white shadow-sm sticky top-0 z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa fa-code text-primary text-2xl"></i>
                <span class="font-bold text-xl">JS Promise 详解</span>
            </div>
            <div class="hidden md:flex space-x-2">
                <a href="#what-is" class="nav-link">什么是 Promise</a>
                <a href="#states" class="nav-link">Promise 状态</a>
                <a href="#methods" class="nav-link">核心方法</a>
                <a href="#examples" class="nav-link">代码示例</a>
                <a href="#scenarios" class="nav-link">使用场景</a>
                <a href="#faq" class="nav-link">常见问题</a>
            </div>
            <button class="md:hidden text-dark" id="menu-toggle">
                <i class="fa fa-bars text-xl"></i>
            </button>
        </div>
        <div class="md:hidden hidden bg-white shadow-md absolute w-full" id="mobile-menu">
            <div class="flex flex-col px-4 py-2">
                <a href="#what-is" class="nav-link border-b border-light">什么是 Promise</a>
                <a href="#states" class="nav-link border-b border-light">Promise 状态</a>
                <a href="#methods" class="nav-link border-b border-light">核心方法</a>
                <a href="#examples" class="nav-link border-b border-light">代码示例</a>
                <a href="#scenarios" class="nav-link border-b border-light">使用场景</a>
                <a href="#faq" class="nav-link">常见问题</a>
            </div>
        </div>
    </nav>

    <header class="bg-primary text-white py-16">
        <div class="container mx-auto px-4 text-center">
            <h1 class="text-4xl font-bold mb-4">JavaScript 异步编程之 Promise 详解</h1>
            <p class="text-lg max-w-3xl mx-auto">从回调地狱到 Promise 链式调用，全面掌握 JavaScript 异步编程的核心解决方案</p>
        </div>
    </header>

    <main class="container mx-auto px-4 py-8 max-w-4xl">
        <section id="what-is" class="card">
            <h2 class="section-title">什么是 Promise</h2>
            <p class="mb-4">Promise 是 JavaScript 中用于处理**异步操作**的对象，它代表了一个异步操作的最终完成（或失败）及其结果值。</p>
            <p class="mb-4">Promise 解决了传统回调函数带来的**回调地狱**问题，使异步代码的逻辑更清晰、更易维护。</p>
            <div class="code-block">
                // Promise 基本结构
                const promise = new Promise((resolve, reject) => {
                    // 异步操作
                    if (/* 操作成功 */) {
                        resolve('成功的结果');
                    } else {
                        reject('失败的原因');
                    }
                });
            </div>
            <p class="text-secondary font-bold">核心特点：</p>
            <ul class="list-disc pl-6 mb-4 space-y-2">
                <li>**异步性**：用于处理非阻塞操作（如网络请求、文件读写）</li>
                <li>**状态不可逆**：一旦状态改变，就不会再变</li>
                <li>**链式调用**：支持 <code class="bg-light px-1 rounded">.then()</code>、<code class="bg-light px-1 rounded">.catch()</code> 链式调用</li>
            </ul>
        </section>

        <section id="states" class="card">
            <h2 class="section-title">Promise 的三种状态</h2>
            <p class="mb-4">Promise 对象存在以下三种状态，状态的改变是**单向**的，只能从Pending向另外两种状态转换。</p>
            <div class="grid md:grid-cols-3 gap-4 mb-6">
                <div class="bg-light p-4 rounded-lg border-l-4 border-yellow-500">
                    <h3 class="font-bold mb-2">Pending（进行中）</h3>
                    <p>初始状态，异步操作尚未完成</p>
                </div>
                <div class="bg-light p-4 rounded-lg border-l-4 border-green-500">
                    <h3 class="font-bold mb-2">Fulfilled（已成功）</h3>
                    <p>异步操作成功完成，调用 <code>resolve()</code></p>
                </div>
                <div class="bg-light p-4 rounded-lg border-l-4 border-red-500">
                    <h3 class="font-bold mb-2">Rejected（已失败）</h3>
                    <p>异步操作失败，调用 <code>reject()</code></p>
                </div>
            </div>
            <div class="code-block">
                // 状态转换示例
                const promise = new Promise((resolve, reject) => {
                    setTimeout(() => {
                        // 500ms 后状态从 Pending -> Fulfilled
                        resolve('操作成功');
                        // 状态一旦改变，后续的 resolve/reject 无效
                        reject('这行代码不会执行');
                    }, 500);
                });
            </div>
        </section>

        <section id="methods" class="card">
            <h2 class="section-title">Promise 核心方法</h2>

            <h3 class="text-xl font-bold mb-3">1. 实例方法</h3>
            <div class="space-y-4 mb-6">
                <div>
                    <p class="font-bold text-primary">.then(onFulfilled, onRejected)</p>
                    <p class="mb-2">处理成功的结果，可选第二个参数处理失败</p>
                    <div class="code-block">
promise
  .then(result => {
    console.log('成功:', result);
    return result + ' 继续处理';
  }, error => {
    console.log('失败:', error);
  })
  .then(newResult => {
    console.log('链式调用:', newResult);
  });
                    </div>
                </div>
                <div>
                    <p class="font-bold text-primary">.catch(onRejected)</p>
                    <p class="mb-2">专门处理失败的情况，捕获链式调用中的所有错误</p>
                    <div class="code-block">
promise
  .then(result => {
    console.log('成功:', result);
    throw new Error('手动抛出错误');
  })
  .catch(error => {
    console.log('捕获错误:', error.message);
  });
                    </div>
                </div>
                <div>
                    <p class="font-bold text-primary">.finally(onFinally)</p>
                    <p class="mb-2">无论成功还是失败，都会执行的回调函数</p>
                    <div class="code-block">
promise
  .then(result => console.log('成功:', result))
  .catch(error => console.log('失败:', error))
  .finally(() => console.log('操作完成，无论成功与否'));
                    </div>
                </div>
            </div>

            <h3 class="text-xl font-bold mb-3">2. 静态方法</h3>
            <div class="space-y-4">
                <div>
                    <p class="font-bold text-primary">Promise.resolve(value)</p>
                    <p class="mb-2">快速创建一个已成功的 Promise</p>
                </div>
                <div>
                    <p class="font-bold text-primary">Promise.reject(reason)</p>
                    <p class="mb-2">快速创建一个已失败的 Promise</p>
                </div>
                <div>
                    <p class="font-bold text-primary">Promise.all(iterable)</p>
                    <p class="mb-2">等待所有 Promise 都成功，才返回成功结果数组；只要有一个失败，立即返回失败</p>
                </div>
                <div>
                    <p class="font-bold text-primary">Promise.race(iterable)</p>
                    <p class="mb-2">返回第一个完成的 Promise 的结果（无论成功或失败）</p>
                </div>
                <div>
                    <p class="font-bold text-primary">Promise.allSettled(iterable)</p>
                    <p class="mb-2">等待所有 Promise 都完成，返回每个 Promise 的结果对象（包含状态和值）</p>
                </div>
            </div>
        </section>
        <section id="examples" class="card">
            <h2 class="section-title">实战代码示例</h2>

            <h3 class="text-xl font-bold mb-3">示例 1：基本使用</h3>
            <div class="code-block">
// 模拟网络请求
function fetchData(url) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (url) {
                resolve({ status: 200, data: '请求成功的数据' });
            } else {
                reject(new Error('URL 不能为空'));
            }
        }, 1000);
    });
}

// 使用 Promise
fetchData('https://api.example.com')
    .then(response => {
        console.log('响应状态:', response.status);
        return response.data;
    })
    .then(data => {
        console.log('响应数据:', data);
    })
    .catch(error => {
        console.error('请求失败:', error.message);
    })
    .finally(() => {
        console.log('请求完成');
    });
            </div>

            <h3 class="text-xl font-bold mb-3 mt-6">示例 2：Promise.all 并行请求</h3>
            <div class="code-block">
// 多个并行请求
const request1 = fetchData('https://api.example.com/user');
const request2 = fetchData('https://api.example.com/posts');
const request3 = fetchData('https://api.example.com/comments');

// 等待所有请求完成
Promise.all([request1, request2, request3])
    .then(responses => {
        console.log('所有请求成功:', responses);
        const [user, posts, comments] = responses;
        // 处理所有数据
    })
    .catch(error => {
        console.error('有请求失败:', error.message);
    });
            </div>

            <h3 class="text-xl font-bold mb-3 mt-6">示例 3：Promise 链式调用解决回调地狱</h3>
            <div class="code-block">
// 回调地狱（不推荐）
fetchUser(userId, (user) => {
    fetchPosts(user.id, (posts) => {
        fetchComments(posts[0].id, (comments) => {
            console.log('评论数据:', comments);
        });
    });
});

// Promise 链式调用（推荐）
fetchUserPromise(userId)
    .then(user => fetchPostsPromise(user.id))
    .then(posts => fetchCommentsPromise(posts[0].id))
    .then(comments => console.log('评论数据:', comments))
    .catch(error => console.error('错误:', error));
            </div>
        </section>

        <section id="scenarios" class="card">
            <h2 class="section-title">Promise 常见使用场景</h2>
            <ul class="list-disc pl-6 space-y-4">
                <li>
                    <span class="font-bold">网络请求</span>
                    <p class="mt-1">Fetch API、Axios 等 HTTP 客户端均基于 Promise 实现</p>
                    <div class="code-block mt-2">
// Fetch API 示例
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));
                    </div>
                </li>
                <li>
                    <span class="font-bold">文件操作</span>
                    <p class="mt-1">浏览器端的 FileReader 或 Node.js 中的文件系统操作</p>
                </li>
                <li>
                    <span class="font-bold">定时器操作</span>
                    <p class="mt-1">封装 setTimeout、setInterval 为 Promise 形式</p>
                </li>
                <li>
                    <span class="font-bold">异步操作队列</span>
                    <p class="mt-1">按顺序执行多个异步操作</p>
                </li>
                <li>
                    <span class="font-bold">与 async/await 结合</span>
                    <p class="mt-1">Promise 的语法糖，使异步代码看起来像同步代码</p>
                    <div class="code-block mt-2">
// async/await 示例
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}
                    </div>
                </li>
            </ul>
        </section>

        <section id="faq" class="card">
            <h2 class="section-title">常见问题与注意事项</h2>
            <div class="space-y-6">
                <div>
                    <h3 class="font-bold text-primary mb-2">Q1: Promise 真的解决了回调地狱吗？</h3>
                    <p>A: Promise 通过**链式调用**改善了回调地狱的嵌套问题，但复杂的业务逻辑仍可能导致长链。结合 <code>async/await</code> 可以获得更好的可读性。</p>
                </div>
                <div>
                    <h3 class="font-bold text-primary mb-2">Q2: Promise 中的错误如何捕获？</h3>
                    <p>A: 有两种方式：</p>
                    <ul class="list-disc pl-6 mt-2">
                        <li>使用 <code>.catch()</code> 方法捕获链式调用中的所有错误</li>
                        <li>在 <code>async/await</code> 中使用 <code>try/catch</code> 块</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-bold text-primary mb-2">Q3: Promise.all 和 Promise.race 的区别？</h3>
                    <p>A: </p>
                    <ul class="list-disc pl-6 mt-2">
                        <li><code>Promise.all</code>：等待所有 Promise 完成，全部成功才返回成功数组</li>
                        <li><code>Promise.race</code>：返回第一个完成的 Promise 的结果，无论成功或失败</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-bold text-primary mb-2">Q4: Promise 可以取消吗？</h3>
                    <p>A: 原生 Promise 不支持取消操作。可以通过以下方式实现类似效果：</p>
                    <ul class="list-disc pl-6 mt-2">
                        <li>使用第三方库（如 Bluebird）</li>
                        <li>自己实现取消逻辑（通过标志位）</li>
                        <li>使用 ES2021 中的 <code>AbortController</code>（主要用于 Fetch API）</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-bold text-primary mb-2">Q5: Promise 与 async/await 的关系？</h3>
                    <p>A: <code>async/await</code> 是 Promise 的**语法糖**，底层仍然基于 Promise 实现。它使异步代码的写法更接近同步代码，可读性更高。</p>
                </div>
            </div>
        </section>
    </main>

    <footer class="bg-dark text-white py-8">
        <div class="container mx-auto px-4 text-center">
            <p class="mb-2">JavaScript 异步编程之 Promise 详解</p>
            <p class="text-gray-400 text-sm">© 2026 JS 前端技术文档 | 基于 Promise 核心原理构建</p>
        </div>
    </footer>
    <script>
        const menuToggle = document.getElementById('menu-toggle');
        const mobileMenu = document.getElementById('mobile-menu');

        menuToggle.addEventListener('click', () => {
            mobileMenu.classList.toggle('hidden');
        });

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    window.scrollTo({
                        top: targetElement.offsetTop - 80,
                        behavior: 'smooth'
                    });
                    
                    if (!mobileMenu.classList.contains('hidden')) {
                        mobileMenu.classList.add('hidden');
                    }
                }
            });
        });
        document.querySelectorAll('.code-block').forEach(block => {
            const code = block.innerHTML;
            const highlighted = code
                .replace(/(const|let|var|function|return|if|else|new|async|await)/g, '<span class="text-yellow-400">$1</span>')
                .replace(/(resolve|reject|then|catch|finally)/g, '<span class="text-green-400">$1</span>')
                .replace(/(Promise)/g, '<span class="text-secondary">$1</span>')
                .replace(/('.*?'|".*?")/g, '<span class="text-red-400">$1</span>')
                .replace(/(\/\/.*)/g, '<span class="text-gray-400">$1</span>');
            
            block.innerHTML = highlighted;
        });
    </script>
</body>
</html>